<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>homework3최종안</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <!-- <script src="./dat.gui.js"></script> -->
  <script type="importmap">
    {
      "imports": {
        "three": "./three.js-master/build/three.module.js",
        "three/addons/": "./three.js-master/examples/jsm/"
      }
    }
  </script>
  <body>
    <script type="module">
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      let loader = new GLTFLoader();
      console.clear();
      //let gui = new dat.GUI();
      const {
        devicePixelRatio,
        innerHeight: viewportHeight,
        innerWidth: viewportWidth,
      } = window;

      class Scene extends THREE.Scene {
        #controls;
        #orbital;
        #player;
        #prevTimestamp;
        #renderer;
        #scene;

        static timeDilation = 0.4;
        constructor(props) {
          super(props);

          this.#renderer = new THREE.WebGLRenderer({ antialias: true });

          this.#addLights();
          this.#standardSet();
          this.main();
          this.#controls = {
            position: new KeyboardInput({
              left: "a",
              right: "d",
              up: "s",
              down: "w",
            }),
            rotation: new KeyboardInput({
              left: "arrowleft",
              right: "arrowright",
              up: "arrowup",
              down: "arrowdown",
            }),
          };

          this.#player = new Player({
            animationNames: ["idle", "walk", "run"],
            modelName: "root",
            onLoad: () =>
              (document.querySelector("#loading").style.display = "none"),
            path: "https://assets.codepen.io/829639/",
          });
          this.add(this.#player);

          this.#orbital = new OrbitalCamera(
            60,
            viewportWidth / viewportHeight,
            1,
            1000
          );
          // Add the orbital to the player, not to the scene
          this.#player.add(this.#orbital);

          document.body.appendChild(this.#renderer.domElement);
          this.#renderer.setAnimationLoop(this.#render);
        }

        #standardSet() {
          this.background = new THREE.TextureLoader().load("img/sky2.jpg"); // 배경
          const field_geo = new THREE.PlaneGeometry(1000, 1000);
          var texture_field = new THREE.TextureLoader().load(
            "img/grass-field.jpg"
          );
          texture_field;
          texture_field.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texture_field.wrapT = THREE.RsepeatWrapping;
          texture_field.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texture_field.repeat.set(20, 20);
          const field_mat = new THREE.MeshStandardMaterial({
            map: texture_field,
            normalMap: texture_field,
            displacementMap: texture_field,
            displacementScale: 1,
          });
          const field = new THREE.Mesh(field_geo, field_mat);
          field.receiveShadow = true;
          field.rotation.x = 1.5 * Math.PI;
          field.position.y = -1;
          this.add(field);
        }
        //#allset (){
        async main() {
          //desk A
          //desk A
          //desk A
          //desk A
          //desk A
          //desk A
          //desk A
          //desk A
          //desk A
          //desk A

          var desk_2f_A = new THREE.Object3D();

          var table_size = 1; //크기변경 하려면 이놈 건들기
          var table_lenth = 5 * table_size;
          var radius = table_lenth / 2;
          var Angle = 120 * (Math.PI / 180);
          var Angle_sub = 60 * (Math.PI / 180);
          var chair_size = table_size * 3;
          var table_leg_height = 3;
          var table_leg_size = 0.3;

          async function loadModel_desk_2f_A(i, scaleFactor) {
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                "models/muskonge_n24t6n23s2001/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var chair = gltf.scene;
            chair.position.set(
              radius * Math.sin(Angle * i + Angle_sub),
              0,
              radius * Math.cos(Angle * i + Angle_sub)
            );
            chair.rotation.y = Angle * i + Angle_sub * 4;
            chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
            desk_2f_A.add(chair);

            loader.load(
              "models/black_power_socket/scene.gltf",
              function (gltf) {
                var power_soket = gltf.scene;
                power_soket.position.set(
                  (radius * Math.sin(Angle * i + Angle_sub)) / 5,
                  3.16,
                  (radius * Math.cos(Angle * i + Angle_sub)) / 5
                );
                power_soket.rotation.z = Angle * i + Angle_sub * 4;
                power_soket.rotation.x = (-Math.PI * 3) / 2;
                power_soket.scale.set(1, 1, 1);
                desk_2f_A.add(power_soket);
              },
              undefined,
              function (error) {
                console.error(error);
              }
            );
          }

          const table_geo = new THREE.BoxGeometry(
            table_lenth * 0.5,
            0.3,
            (table_lenth * 4) / 5
          );
          const table_texture = new THREE.TextureLoader().load("img/wood1.jpg");
          table_texture.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          table_texture.wrapT = THREE.RsepeatWrapping;
          table_texture.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          table_texture.repeat.set(5, 1);
          const table_mat = new THREE.MeshPhongMaterial({ map: table_texture });

          const table_leg_geo = new THREE.BoxGeometry(
            table_leg_size,
            table_leg_height,
            table_leg_size
          );
          const table_leg_geo3 = new THREE.BoxGeometry(
            table_leg_size,
            table_leg_size,
            table_lenth * 0.5
          );
          const table_leg_mat = new THREE.MeshPhongMaterial({
            color: 0x000000,
          });
          const table_leg_plane_geo = new THREE.PlaneGeometry(
            table_lenth * 0.5 - 0.5,
            table_leg_height / 2
          );
          const table_leg_plane_mat = new THREE.MeshPhongMaterial({
            color: 0xd89bd8,
          });

          for (var i = 0; i < 3; i++) {
            var table = new THREE.Mesh(table_geo, table_mat);
            table.castShadow = true;

            table.position.set(
              radius * Math.sin(Angle * i),
              table_leg_height,
              radius * Math.cos(Angle * i)
            );
            table.rotation.y = Angle * i;

            var table_leg = new THREE.Mesh(table_leg_geo, table_leg_mat);
            table_leg.castShadow = true;

            var table_leg2 = new THREE.Mesh(table_leg_geo, table_leg_mat);
            table_leg2.castShadow = true;

            table_leg.position.set(
              (table_lenth * 0.5) / 2 - table_leg_size / 1.8,
              -table_leg_height / 2,
              0
            );
            table_leg2.position.set(
              (-table_lenth * 0.5) / 2 + table_leg_size / 1.8,
              -table_leg_height / 2,
              0
            );
            table.add(table_leg);
            table.add(table_leg2);
            var table_leg3 = new THREE.Mesh(table_leg_geo3, table_leg_mat);
            table_leg3.castShadow = true;

            table_leg3.position.set(0, -table_leg_height / 2, 0);
            table_leg3.rotation.y = Math.PI * 0.5;
            table.add(table_leg3);
            var table4 = new THREE.Mesh(table_geo, table_mat);
            table4.castShadow = true;

            table4.position.set(0, 0, -0.5);
            table.add(table4);
            var table_leg_plane = new THREE.Mesh(
              table_leg_plane_geo,
              table_leg_plane_mat
            );
            table_leg_plane.position.set(0, -table_leg_height / 4, 0);
            table.add(table_leg_plane);

            desk_2f_A.add(table);
            await loadModel_desk_2f_A(i, 3); //의자 모델 불러오기
          }

          //desk B
          //desk B
          //desk B
          //desk B
          //desk B
          //desk B
          //desk B
          //desk B
          //desk B
          //desk B

          var desk_2f_B = new THREE.Object3D();

          var desk_2f_B_frame = new THREE.Object3D();
          //사이즈 조절용 변수
          var table_B_size = 1.8;

          //기본 넓은 desk
          const table_B_geo = new THREE.BoxGeometry(
            table_lenth * table_B_size * 2,
            0.3,
            table_lenth * table_B_size * 1.2
          );
          const table_B = new THREE.Mesh(table_B_geo, table_mat);
          table_B.castShadow = true;

          table_B.position.set(0, table_leg_height, 0);
          desk_2f_B.add(table_B);

          //세로 기둥 2개
          var table_B_frame_height = 10;
          const table_B_frame_geo = new THREE.BoxGeometry(
            table_leg_size * table_B_size,
            table_B_frame_height,
            table_leg_size * table_B_size
          );
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 8; i++) {
              var tmp_table_B_frame = new THREE.Mesh(
                table_B_frame_geo,
                table_leg_mat
              );
              tmp_table_B_frame.castShadow = true;

              tmp_table_B_frame.position.set(
                (-1) ** j *
                  (table_lenth * table_B_size +
                    (table_leg_size * table_B_size) / 2),
                table_B_frame_height / 2,
                table_leg_size * table_B_size * 10 -
                  i * table_leg_size * table_B_size * 2.8
              );
              desk_2f_B_frame.add(tmp_table_B_frame);
            }
          }

          //천장쪽 누운기둥 8개
          const table_B_frame_geo2 = new THREE.BoxGeometry(
            table_leg_size * table_B_size,
            table_lenth * table_B_size * 2,
            table_leg_size * table_B_size
          );
          for (var i = 0; i < 8; i++) {
            var tmp_table_B_frame = new THREE.Mesh(
              table_B_frame_geo2,
              table_leg_mat
            );
            tmp_table_B_frame.castShadow = true;

            tmp_table_B_frame.rotation.z = Math.PI * 0.5;
            tmp_table_B_frame.position.set(
              0,
              table_B_frame_height,
              table_leg_size * table_B_size * 10 -
                i * table_leg_size * table_B_size * 2.8
            );
            desk_2f_B_frame.add(tmp_table_B_frame);
          }

          //테두리 4개 위에 맨사이드 2개 아래 맨사이드 2개
          const table_B_frame_geo3 = new THREE.BoxGeometry(
            table_leg_size * table_B_size,
            table_leg_size * table_B_size * 20 + 0.3,
            table_leg_size * table_B_size
          );
          for (var i = 0; i < 2; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_table_B_frame = new THREE.Mesh(
                table_B_frame_geo3,
                table_leg_mat
              );
              tmp_table_B_frame.rotation.x = Math.PI * 0.5;
              tmp_table_B_frame.position.set(
                (-1) ** i *
                  (table_lenth * table_B_size +
                    (table_leg_size * table_B_size) / 2),
                j * table_B_frame_height,
                0.1
              );
              desk_2f_B_frame.add(tmp_table_B_frame);
            }
          }
          //의자 불러오는 함수
          async function loadModel_desk_2f_B(i, j, scaleFactor) {
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                "models/muskonge_n24t6n23s2001/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var chair = gltf.scene;
            chair.position.set(
              table_lenth * table_B_size * 0.8 -
                (i * table_lenth * table_B_size) / 2,
              0,
              (-1) ** j * table_lenth * table_B_size * 0.7
            );
            if (!j) {
              chair.rotation.y = Math.PI;
            }
            chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
            desk_2f_B.add(chair);
          }
          //의자 8개 배치
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 4; i++) {
              await loadModel_desk_2f_B(i, j, 3);
            }
          }
          desk_2f_B.add(desk_2f_B_frame);

          //desk C
          //desk C
          //desk C
          //desk C
          //desk C
          //desk C
          //desk C
          //desk C
          //desk C

          var desk_2f_C = new THREE.Object3D();
          var table_C_size = table_lenth * 1.5;

          //책상 윗판 조망형
          const table_C_geo = new THREE.BoxGeometry(
            table_C_size,
            0.3,
            table_C_size / 2
          );
          const table_C = new THREE.Mesh(table_C_geo, table_mat);
          table_C.castShadow = true;

          table_C.position.set(0, table_leg_height, 0);
          desk_2f_C.add(table_C);

          //책상다리
          const table_C_leg_geo = new THREE.BoxGeometry(
            table_leg_size,
            table_leg_height,
            table_leg_size
          );
          const table_C_leg1 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
          table_C_leg1.position.set(
            -table_C_size / 2 + table_leg_size / 2,
            table_leg_height / 2,
            table_C_size / 4 - table_leg_size / 2
          );
          desk_2f_C.add(table_C_leg1);

          const table_C_leg2 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
          table_C_leg2.position.set(
            table_C_size / 2 - table_leg_size / 2,
            table_leg_height / 2,
            table_C_size / 4 - table_leg_size / 2
          );
          desk_2f_C.add(table_C_leg2);

          const table_C_leg3 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
          table_C_leg3.position.set(
            -table_C_size / 2 + table_leg_size / 2,
            table_leg_height / 2,
            -table_C_size / 4 + table_leg_size / 2
          );
          desk_2f_C.add(table_C_leg3);

          const table_C_leg4 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
          table_C_leg4.position.set(
            table_C_size / 2 - table_leg_size / 2,
            table_leg_height / 2,
            -table_C_size / 4 + table_leg_size / 2
          );
          desk_2f_C.add(table_C_leg4);

          async function loadModel_desk_2f_C(scaleFactor) {
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                "models/muskonge_n24t6n23s2001/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var chair = gltf.scene;
            chair.position.set(table_C_size / 4, 0, table_C_size / 3);
            chair.rotation.y = Math.PI;
            chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
            desk_2f_C.add(chair);

            const gltf2 = await new Promise((resolve, reject) => {
              loader.load(
                "models/muskonge_n24t6n23s2001/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var chair2 = gltf2.scene;
            chair2.position.set(-table_C_size / 4, 0, table_C_size / 3);
            chair2.rotation.y = Math.PI;
            chair2.scale.set(scaleFactor, scaleFactor, scaleFactor);
            desk_2f_C.add(chair2);

            const gltf3 = await new Promise((resolve, reject) => {
              loader.load(
                "models/stand_lamp/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var lamp = gltf3.scene;
            lamp.position.set(
              table_C_size / 4 + table_C_size / 6,
              table_leg_height + 0.15,
              -table_C_size / 8
            );
            lamp.rotation.y = Math.PI;
            lamp.scale.set(scaleFactor, scaleFactor, scaleFactor);
            desk_2f_C.add(lamp);

            const gltf4 = await new Promise((resolve, reject) => {
              loader.load(
                "models/stand_lamp/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var lamp2 = gltf4.scene;
            lamp2.position.set(
              -table_C_size / 4 + table_C_size / 6,
              table_leg_height + 0.15,
              -table_C_size / 8
            );
            lamp2.rotation.y = Math.PI;
            lamp2.scale.set(3, 3, 3);
            desk_2f_C.add(lamp2);
          }

          await loadModel_desk_2f_C(3);

          //deskD
          //deskD
          //deskD
          //deskD
          //deskD
          //deskD
          //deskD
          //deskD
          //deskD
          //deskD
          //deskD

          var desk_2f_D = new THREE.Object3D();
          var table_D_size = 1.8;
          //기본 넓은 desk
          const table_D_geo = new THREE.BoxGeometry(
            table_lenth * table_D_size * 2,
            0.3,
            table_lenth * table_D_size * 0.6
          );
          const table_D = new THREE.Mesh(table_D_geo, table_mat);
          table_D.castShadow = true;
          table_D.position.set(0, table_leg_height, 0);
          desk_2f_D.add(table_D);
          //의자 불러오는 함수
          async function loadModel_desk_2f_D(i, j, scaleFactor) {
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                "models/muskonge_n24t6n23s2001/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });

            var chair = gltf.scene;
            chair.position.set(
              table_lenth * table_D_size * 0.8 -
                (i * table_lenth * table_D_size) / 2,
              0,
              (-1) ** j * table_lenth * table_D_size * 0.4
            ); //.7
            if (!j) {
              chair.rotation.y = Math.PI;
            }
            chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
            desk_2f_D.add(chair);
          }
          //다리배치
          for (var i = 0; i < 2; i++) {
            for (var j = 0; j < 2; j++) {
              var table_leg = new THREE.Mesh(table_leg_geo, table_leg_mat);
              table_leg.position.set(
                (-1) ** i * (table_lenth * table_D_size - table_leg_size / 1.8),
                -table_leg_height / 2,
                (-1) ** j * table_lenth * table_D_size * 0.3
              );
              table_D.add(table_leg);
            }
          }

          //의자 8개 배치
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 4; i++) {
              await loadModel_desk_2f_D(i, j, 3);
            }
          }

          desk_2f_D.rotation.y = Math.PI * 0.5;

          //계단옆 유리
          //계단옆 유리
          //계단옆 유리
          //계단옆 유리
          //계단옆 유리
          //계단옆 유리
          //계단옆 유리
          //계단옆 유리
          //계단옆 유리

          //계단 유리창
          var stare_side = new THREE.Object3D();

          var stare_glace_size = 8;
          const stare_glace_geo = new THREE.PlaneGeometry(
            stare_glace_size,
            (table_leg_height / 3) * 7
          );
          const stare_glace_mat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            //metalness:.05,
            roughness: 0.05,
            ior: 1.4, //1.4~1.7유리매질
            thickness: 0.2,
            transmission: 1,
            side: THREE.DoubleSide,
          });
          const stare_glace = new THREE.Mesh(stare_glace_geo, stare_glace_mat);
          stare_glace.position.set(0, table_leg_height / 2, 0);
          stare_side.add(stare_glace);

          //유리창 손잡이
          var glace_handle_size = 0.25;
          const glace_handle_geo = new THREE.CylinderGeometry(
            glace_handle_size,
            glace_handle_size,
            stare_glace_size,
            50
          );
          const glace_handle_mat = new THREE.MeshPhysicalMaterial({
            color: 0xd1d1d1,
            emissive: 0x999999,
            roughness: 1,
            metalness: 1,
            clearcoat: 0.22,
          });
          const glace_handle = new THREE.Mesh(
            glace_handle_geo,
            glace_handle_mat
          );
          stare_side.add(glace_handle);
          glace_handle.rotation.z = Math.PI * 0.5;
          glace_handle.position.set(0, (table_leg_height / 3) * 4, 1);

          //유리창 사이드
          const glace_side_geo = new THREE.BoxGeometry(
            glace_handle_size,
            (table_leg_height / 3) * 7,
            glace_handle_size
          );
          const glace_side = new THREE.Mesh(glace_side_geo, glace_handle_mat);
          glace_side.position.set(
            stare_glace_size / 2,
            (table_leg_height / 12) * 7,
            0
          );
          stare_side.add(glace_side);

          const glace_side1 = new THREE.Mesh(glace_side_geo, glace_handle_mat);
          glace_side1.position.set(
            -stare_glace_size / 2,
            (table_leg_height / 12) * 7,
            0
          );
          stare_side.add(glace_side1);

          //유리창 세로 기둥
          const glace_side2_geo = new THREE.BoxGeometry(
            glace_handle_size,
            1,
            glace_handle_size
          );
          const glace_side3 = new THREE.Mesh(glace_side2_geo, glace_handle_mat);
          const glace_side4 = new THREE.Mesh(glace_side2_geo, glace_handle_mat);
          glace_side3.position.set(
            -stare_glace_size / 2,
            (table_leg_height / 3) * 4,
            0.5
          );
          glace_side4.position.set(
            stare_glace_size / 2,
            (table_leg_height / 3) * 4,
            0.5
          );
          glace_side3.rotation.x = Math.PI * 0.5;
          glace_side4.rotation.x = Math.PI * 0.5;
          stare_side.add(glace_side3);
          stare_side.add(glace_side4);

          //기둥
          //기둥
          //기둥
          //기둥
          //기둥
          //기둥
          //기둥
          //기둥
          //기둥
          var pillar = new THREE.Object3D();

          var height_2f = 25;
          var pillar_size = 3;
          var pillar_height = height_2f;

          const pillar_geo = new THREE.BoxGeometry(
            pillar_size,
            pillar_height,
            pillar_size
          );
          const texturedesk = new THREE.TextureLoader().load(
            "img/white-wall.jpg"
          );
          texturedesk.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texturedesk.wrapT = THREE.RepeatWrapping;
          texturedesk.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texturedesk.repeat.set(1, pillar_height / 4);
          const pillar_mat = new THREE.MeshStandardMaterial({
            map: texturedesk,
          });
          const pillar_obj = new THREE.Mesh(pillar_geo, pillar_mat);
          pillar_obj.receiveShadow = true;
          pillar_obj.position.set(0, pillar_height / 2, 0);
          pillar.add(pillar_obj);

          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽
          //2,3층 외벽

          var pillar_size = 4;
          var pillar_height = height_2f;
          var wall_out_size = pillar_size; // pillar_size를 사용
          var wall_out_size2 = wall_out_size * 1.5;
          var wall_out_half = wall_out_size2 / 2;

          var wall_window = new THREE.Object3D();

          var window_glace_size = wall_out_size2 * 2;
          const window_glace_geo = new THREE.PlaneGeometry(
            wall_out_size * 2,
            pillar_height
          ); // wall_out_size를 사용
          const window_glace_mat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.05,
            ior: 1.7,
            thickness: 0.5,
            transmission: 1,
            side: THREE.DoubleSide,
          });
          const window_glace = new THREE.Mesh(
            window_glace_geo,
            window_glace_mat
          );
          window_glace.position.set(0, pillar_height / 2, 0);
          wall_window.add(window_glace);

          const window_frame_geo = new THREE.PlaneGeometry(
            wall_out_size * 2,
            0.5
          );
          const window_frame_mat = new THREE.MeshStandardMaterial({
            color: 0x000000,
          });
          const window_frame1 = new THREE.Mesh(
            window_frame_geo,
            window_frame_mat
          );
          window_frame1.position.set(
            0,
            -pillar_height / 2 + table_leg_height * 1.5,
            -0.5
          );
          const window_frame2 = new THREE.Mesh(
            window_frame_geo,
            window_frame_mat
          );
          window_frame2.position.set(
            0,
            -pillar_height / 2 + table_leg_height,
            -0.5
          );
          window_glace.add(window_frame1);
          window_glace.add(window_frame2);

          //세로벽
          var wall_out = new THREE.Object3D();

          const wall_out_geo = new THREE.BoxGeometry(
            wall_out_size2,
            pillar_height,
            wall_out_size2
          );
          const wall_out_mat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
          });
          const wall_out_obj = new THREE.Mesh(wall_out_geo, wall_out_mat);
          wall_out_obj.position.set(0, pillar_height / 2, 0); // position 오타 수정
          wall_out.add(wall_out_obj);

          //가로벽
          var wall_out2 = new THREE.Object3D();

          const wall_out_geo2 = new THREE.BoxGeometry(
            wall_out_size2 * 2,
            wall_out_size / 10,
            wall_out_size2
          );
          const wall_out_obj2 = new THREE.Mesh(wall_out_geo2, wall_out_mat);
          wall_out_obj2.position.set(0, height_2f - wall_out_size / 20, 0);
          wall_out2.add(wall_out_obj2);
          var tmp_wal_out2 = wall_out2.clone();
          tmp_wal_out2.position.set(0, -height_2f + wall_out_size / 10, 0);
          wall_window.add(wall_out2);
          wall_window.add(tmp_wal_out2);

          //가로 네모
          const wall_box_geo = new THREE.BoxGeometry(
            wall_out_size2,
            wall_out_size2,
            wall_out_size
          );
          const wall_box_mat = new THREE.MeshPhongMaterial({ color: 0x595959 });
          const wall_box = new THREE.Mesh(wall_box_geo, wall_box_mat);
          wall_box.position.set(
            0,
            height_2f - wall_out_size / 20 - (wall_out_size * 1.8) / 2,
            -wall_out_size * 0.3
          );
          wall_window.add(wall_box);

          //바닥
          //바닥
          //바닥
          //바닥
          //바닥
          //바닥
          //바닥
          //바닥

          var floor_size = 24;
          var floor_width = floor_size * 12;
          var floor_height = floor_width / 3;
          const pgeometry = new THREE.PlaneGeometry(floor_width, floor_height);
          const texturefloor = new THREE.TextureLoader().load(
            "img/2f_floor_texture.jpg"
          );
          texturefloor.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texturefloor.wrapT = THREE.RepeatWrapping;
          texturefloor.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texturefloor.repeat.set(floor_width / 5, floor_height / 5);
          const pmaterial = new THREE.MeshPhongMaterial({
            map: texturefloor,
            side: THREE.DoubleSide,
          });

          const plane3 = new THREE.Mesh(pgeometry, pmaterial);
          plane3.rotation.x = 1.5 * Math.PI;
          plane3.position.set(0, 0, 0);
          plane3.receiveShadow = true;

          var front_glass_size = 50; //정면 유리사이즈
          //2층 내벽
          var floor_2f_insideWall_size = floor_size;
          const floor_2f_insideWall_geo = new THREE.PlaneGeometry(
            floor_2f_insideWall_size,
            height_2f
          );
          const textureInsideWall = new THREE.TextureLoader().load(
            "img/2f_wall_inside.jpg"
          );
          textureInsideWall.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          textureInsideWall.wrapT = THREE.RepeatWrapping;
          textureInsideWall.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          textureInsideWall.repeat.set(
            floor_2f_insideWall_size / 6,
            height_2f / 5
          );
          const floor_2f_insideWall_mat = new THREE.MeshStandardMaterial({
            map: textureInsideWall,
            side: THREE.DoubleSide,
          });
          const floor_2f_insideWall_object = new THREE.Mesh(
            floor_2f_insideWall_geo,
            floor_2f_insideWall_mat
          );
          floor_2f_insideWall_object.receiveShadow = true;
          var floor_2f_insideWall = new THREE.Object3D();
          floor_2f_insideWall.position.set(
            floor_2f_insideWall_size / 2 + front_glass_size / 2,
            height_2f / 2,
            floor_height / 2 - floor_2f_insideWall_size
          );
          floor_2f_insideWall.rotation.y = Math.PI;
          floor_2f_insideWall.add(floor_2f_insideWall_object);

          var floor_2f_insideWall_2 = floor_2f_insideWall.clone();
          floor_2f_insideWall_2.position.set(
            -floor_2f_insideWall_size / 2 - front_glass_size / 2,
            height_2f / 2,
            floor_height / 2 - floor_2f_insideWall_size
          );

          var floor_2f_insideWall_3 = floor_2f_insideWall.clone();
          floor_2f_insideWall_3.position.set(
            (floor_2f_insideWall_size / 2) * 3 + front_glass_size / 2,
            height_2f / 2,
            floor_height / 2 - floor_2f_insideWall_size
          );

          const textureInsideWall_2 = new THREE.TextureLoader().load(
            "img/white-wall.jpg"
          );
          textureInsideWall_2.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          textureInsideWall_2.wrapT = THREE.RepeatWrapping;
          textureInsideWall_2.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          textureInsideWall_2.repeat.set(1, pillar_height / 4);
          const study_room_wall_mat = new THREE.MeshPhongMaterial({
            map: textureInsideWall_2,
            side: THREE.DoubleSide,
          });
          const study_room_wall_object = new THREE.Mesh(
            floor_2f_insideWall_geo,
            study_room_wall_mat
          );
          study_room_wall_object.receiveShadow = true;
          var study_room_wall = new THREE.Object3D();
          study_room_wall.add(study_room_wall_object);
          study_room_wall_object.position.set(0, height_2f / 2, 0);

          //여기서 부터 합치기
          //여기서 부터 합치기
          //여기서 부터 합치기
          //여기서 부터 합치기
          //여기서 부터 합치기
          //여기서 부터 합치기
          //여기서 부터 합치기
          //여기서 부터 합치기

          //2층
          //2층
          //2층
          //2층
          //2층
          //2층
          //2층
          //2층
          //2층
          //2층

          var floor_2 = new THREE.Object3D();
          var floor_3 = new THREE.Object3D();
          floor_3.position.set(0, 50, 0);
          plane3.receiveShadow = true;
          //floor_3.add(plane3);
          //this.add(floor_3);

          //개수와 위치조절

          //중앙 소파배치
          //중앙 소파배치
          //중앙 소파배치
          //중앙 소파배치
          //중앙 소파배치
          //중앙 소파배치
          //중앙 소파배치

          var sofa_set = new THREE.Object3D();
          async function loadModel_sofa(i, j, k, z) {
            const gltf = await new Promise((resolve, reject) => {
              loader.load(
                "models/mini_sofa/scene.gltf",
                resolve,
                undefined,
                reject
              );
            });
            var sofa = gltf.scene;
            sofa.position.set(
              (-1) ** k * (floor_size / 4) + (-1) ** j * 1.5,
              1.3,
              -2 + 1.5 * i - 6 * z
            );
            sofa.scale.set(1, 1, 1);
            sofa_set.add(sofa);
          }
          for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
              for (var k = 0; k < 2; k++) {
                for (var z = 0; z < 2; z++) {
                  await loadModel_sofa(i, j, k, z);
                }
              }
            }
          }

          floor_2.add(sofa_set);

          //내벽 세팅
          floor_2.add(floor_2f_insideWall);
          floor_2.add(floor_2f_insideWall_2);
          floor_2.add(floor_2f_insideWall_3);
          for (var i = 0; i < 2; i++) {
            var tmp_model = floor_2f_insideWall.clone();
            tmp_model.rotation.y = Math.PI * 0.5;
            tmp_model.position.set(
              (-1) ** i * (front_glass_size / 2),
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size / 2
            ); //floor_size*1.5
            floor_2.add(tmp_model);
          }
          var sturdy_room_distance1 = 23.75;
          var sturdy_room_distance2 = 23.6;

          for (var i = 1; i < 5; i++) {
            var tmp_model = study_room_wall.clone();
            tmp_model.position.set(
              -floor_width / 2 + sturdy_room_distance1 * i,
              0,
              floor_height / 2 - floor_2f_insideWall_size / 2
            );
            tmp_model.rotation.y = Math.PI * 0.5;
            floor_2.add(tmp_model);
          }

          for (var i = 1; i < 4; i++) {
            var tmp_model = study_room_wall.clone();
            tmp_model.position.set(
              floor_width / 2 - sturdy_room_distance2 * i,
              0,
              floor_height / 2 - floor_2f_insideWall_size / 2
            );
            tmp_model.rotation.y = Math.PI * 0.5;
            floor_2.add(tmp_model);
          }

          //스터디룸 창문

          const sturdy_room_window_geo1 = new THREE.PlaneGeometry(
            sturdy_room_distance1,
            height_2f
          );
          const sturdy_room_window_geo2 = new THREE.PlaneGeometry(
            sturdy_room_distance2,
            height_2f
          );
          const sturdy_room_window_object1 = new THREE.Mesh(
            sturdy_room_window_geo1,
            window_glace_mat
          );
          const sturdy_room_window_object2 = new THREE.Mesh(
            sturdy_room_window_geo2,
            window_glace_mat
          );
          var sturdy_room_window1 = new THREE.Object3D();
          var sturdy_room_window2 = new THREE.Object3D();
          sturdy_room_window1.add(sturdy_room_window_object1);
          sturdy_room_window2.add(sturdy_room_window_object2);

          //스터디룸 나무 테두리
          const sturdy_room_door_geo = new THREE.BoxGeometry(
            0.5,
            height_2f,
            0.5
          );
          const sturdy_room_door_object = new THREE.Mesh(
            sturdy_room_door_geo,
            table_mat
          );
          var sturdy_room_door = new THREE.Object3D();

          sturdy_room_door.add(sturdy_room_door_object);
          var sturdy_room_door_distance = sturdy_room_distance1 / 3.5;

          //창문과 나무테두리 배치
          for (var i = 1; i < 5; i++) {
            var tmp_model = sturdy_room_window1.clone();
            tmp_model.position.set(
              -floor_width / 2 -
                sturdy_room_distance1 / 2 +
                sturdy_room_distance1 * i,
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size
            );
            var tmp_model2 = sturdy_room_door.clone();
            tmp_model2.position.set(
              -floor_width / 2 + sturdy_room_distance1 * i,
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size
            );
            var tmp_model3 = sturdy_room_door.clone();
            tmp_model3.position.set(
              -floor_width / 2 -
                sturdy_room_door_distance +
                sturdy_room_distance1 * i,
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size
            );

            floor_2.add(tmp_model);
            floor_2.add(tmp_model2);
            floor_2.add(tmp_model3);
          }

          for (var i = 1; i < 4; i++) {
            var tmp_model = sturdy_room_window2.clone();
            tmp_model.position.set(
              floor_width / 2 +
                sturdy_room_distance2 / 2 -
                sturdy_room_distance2 * i,
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size
            );
            var tmp_model2 = sturdy_room_door.clone();
            tmp_model2.position.set(
              floor_width / 2 - sturdy_room_distance2 * i,
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size
            );
            var tmp_model3 = sturdy_room_door.clone();
            tmp_model3.position.set(
              floor_width / 2 +
                sturdy_room_door_distance -
                sturdy_room_distance1 * i,
              height_2f / 2,
              floor_height / 2 - floor_2f_insideWall_size
            );
            floor_2.add(tmp_model);
            floor_2.add(tmp_model3);
            floor_2.add(tmp_model2);
          }

          //스터디룸 내부 자리 세팅
          for (var i = 1; i < 5; i++) {
            var tmp_model = desk_2f_D.clone();
            tmp_model.position.set(
              -floor_width / 2 -
                sturdy_room_distance1 / 2 +
                sturdy_room_distance1 * i,
              0,
              floor_height / 2 - floor_2f_insideWall_size / 2
            );
            floor_2.add(tmp_model);
          }
          for (var i = 1; i < 4; i++) {
            var tmp_model = desk_2f_D.clone();
            tmp_model.position.set(
              floor_width / 2 +
                sturdy_room_distance2 / 2 -
                sturdy_room_distance2 * i,
              0,
              floor_height / 2 - floor_2f_insideWall_size / 2
            );
            floor_2.add(tmp_model);
          }

          // //의자 type : 3인석짜리

          var desk_2f_A_distance = 12;
          for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = desk_2f_A.clone();
              tmp_model.position.set(
                (-1) ** j * (-floor_size * 4.2 - desk_2f_A_distance * i),
                0,
                floor_size / 2 + 2
              );
              floor_2.add(tmp_model);
            }
          }
          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = desk_2f_A.clone();
              tmp_model.position.set(
                (-1) ** j * (-floor_size * 1.6 - desk_2f_A_distance * i),
                0,
                floor_size / 2 + 2
              );
              floor_2.add(tmp_model);
            }
          }

          var distance_adjust = 13;
          // //의자 type : 8인석 짜리
          var desk_2f_B_distance = table_lenth * table_B_size * 1.2;
          for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = desk_2f_B.clone();
              tmp_model.position.set(
                (-1) ** j * (-floor_size - distance_adjust * 3.5 - 50),
                0,
                floor_size / 5 - desk_2f_B_distance * 1.5 * i - 4
              );
              floor_2.add(tmp_model);
            }
          }

          // //의자 type : 조망형
          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = desk_2f_C.clone();
              if (j) {
                tmp_model.rotation.y = Math.PI * -0.5;
              } else {
                tmp_model.rotation.y = Math.PI * 0.5;
              }
              tmp_model.position.set(
                (-1) ** j * (-floor_width / 2 + table_C_size / 4),
                0,
                -floor_height / 2 + table_C_size / 4 + table_C_size * i
              );
              floor_2.add(tmp_model);
            }
          }
          for (var i = 0; i < 14; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = desk_2f_C.clone();
              tmp_model.position.set(
                (-1) ** j *
                  (-floor_width / 2 + table_C_size * 2 + table_C_size * i),
                0,
                -floor_height / 2 + table_C_size / 2
              );
              floor_2.add(tmp_model);
            }
          }

          //계단 벽 유리창
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 8; i++) {
              var tmp_model = stare_side.clone();
              tmp_model.position.set(
                (-1) ** j *
                  (floor_size + distance_adjust + i * stare_glace_size),
                0,
                (-floor_size * 6) / 5 + stare_glace_size * 3
              );
              floor_2.add(tmp_model);
            }
            for (var i = 0; i < 8; i++) {
              var tmp_model = stare_side.clone();
              tmp_model.rotation.y = Math.PI;
              tmp_model.position.set(
                (-1) ** j *
                  (floor_size + distance_adjust + i * stare_glace_size),
                0,
                (-floor_size * 6) / 5
              );
              floor_2.add(tmp_model);
            }

            for (var i = 0; i < 3; i++) {
              var tmp_model = stare_side.clone();
              if (j) {
                tmp_model.rotation.y = Math.PI * 0.5;
              } else {
                tmp_model.rotation.y = Math.PI * -0.5;
              }
              tmp_model.position.set(
                (-1) ** j *
                  (floor_size + distance_adjust - stare_glace_size / 2),
                0,
                (-floor_size * 6) / 5 +
                  stare_glace_size / 2 +
                  i * stare_glace_size
              );
              floor_2.add(tmp_model);
            }
          }

          // 중간 기둥
          var pillar_posi_1 = (-floor_size * 6) / 5;
          pillar_posi_1 = 0;
          var pillar_posi_2 = (-floor_size * 12) / 5 + stare_glace_size * 3;
          for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = pillar.clone();
              tmp_model.position.set(
                (-1) ** j *
                  (floor_size / 2 + 2 + distance_adjust + floor_size * 1.6 * i),
                0,
                pillar_posi_1
              );
              floor_2.add(tmp_model);
            }
          }
          for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = pillar.clone();
              tmp_model.position.set(
                (-1) ** j *
                  (floor_size / 2 + 2 + distance_adjust + floor_size * 1.6 * i),
                0,
                pillar_posi_2
              );
              floor_2.add(tmp_model);
            }
          }

          //2층 정면과 기둥사이 벽

          var miniwall_size =
            -floor_height / 2 + (floor_size * 12) / 5 - stare_glace_size * 3;
          const miniwall_geo = new THREE.BoxGeometry(
            miniwall_size,
            height_2f,
            pillar_size
          );
          var miniwall_obj = new THREE.Mesh(miniwall_geo, pillar_mat);
          miniwall_obj.receiveShadow = true;
          miniwall_obj.rotation.y = Math.PI * 0.5;
          miniwall_obj.position.set(
            floor_size / 2 + 2 + distance_adjust,
            pillar_height / 2,
            pillar_posi_2 + miniwall_size / 2
          );
          floor_2.add(miniwall_obj);
          var miniwall_obj2 = new THREE.Mesh(miniwall_geo, pillar_mat);
          miniwall_obj2.receiveShadow = true;
          miniwall_obj2.rotation.y = Math.PI * 0.5;
          miniwall_obj2.position.set(
            -floor_size / 2 - 2 - distance_adjust,
            pillar_height / 2,
            pillar_posi_2 + miniwall_size / 2
          );
          floor_2.add(miniwall_obj2);

          //2층 좌우측 외벽
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 9; i++) {
              var tmp_model = wall_out.clone();
              tmp_model.position.set(
                (-1) ** j * (-floor_width / 2 - wall_out_half),
                0,
                floor_height / 2 - i * window_glace_size
              );
              floor_2.add(tmp_model);
              if (i == 8) {
                continue;
              }
              var tmp_model2 = wall_window.clone();
              tmp_model2.position.set(
                (-1) ** j * (-floor_width / 2 - wall_out_half),
                0,
                floor_height / 2 -
                  ((wall_out_size * 3) / 2 + i * window_glace_size)
              );
              if (j) {
                tmp_model2.rotation.y = Math.PI * -0.5;
              } else {
                tmp_model2.rotation.y = Math.PI * 0.5;
              }
              floor_2.add(tmp_model2);
            }
          }

          //2층 정면 외벽
          for (var k = 0; k < 2; k++) {
            for (var j = 0; j < 2; j++) {
              for (var i = 0; i < 11; i++) {
                var tmp_model = wall_out.clone();
                tmp_model.position.set(
                  (-1) ** j *
                    (+floor_width / 2 + wall_out_half - i * window_glace_size),
                  0,
                  (-1) ** k * (-floor_height / 2 - wall_out_half)
                );
                floor_2.add(tmp_model);
                if (i == 10) {
                  continue;
                }
                var tmp_model2 = wall_window.clone();
                tmp_model2.position.set(
                  (-1) ** j *
                    (+floor_width / 2 +
                      wall_out_half -
                      ((wall_out_size * 3) / 2 + i * window_glace_size)),
                  0,
                  (-1) ** k * (-floor_height / 2 - wall_out_half)
                );
                floor_2.add(tmp_model2);
              }
            }
          }

          //정면 유리와 정면 외벽 까지의 벽

          //정면 유리

          var front_glass_ob = new THREE.Object3D();
          const front_glass_geo = new THREE.PlaneGeometry(
            front_glass_size,
            height_2f
          );
          const front_glass = new THREE.Mesh(front_glass_geo, window_glace_mat);
          front_glass.position.set(0, height_2f / 2, pillar_posi_2);

          const window_frame_geo2 = new THREE.BoxGeometry(
            front_glass_size,
            0.3,
            0.3
          );
          const window_frame_geo3 = new THREE.BoxGeometry(0.3, height_2f, 0.3);
          const window_frame3 = new THREE.Mesh(
            window_frame_geo2,
            window_frame_mat
          );
          const window_frame4 = new THREE.Mesh(
            window_frame_geo3,
            window_frame_mat
          );
          var window_frame_ob = new THREE.Object3D();
          var window_frame_ob1 = new THREE.Object3D();
          window_frame_ob.add(window_frame3);
          window_frame_ob1.add(window_frame4);
          for (var i = 0; i < 5; i++) {
            var tmp_model = window_frame_ob.clone();
            tmp_model.position.set(0, height_2f / 2 - (height_2f / 4) * i, 0);
            front_glass.add(tmp_model);
          }
          for (var i = 0; i < 6; i++) {
            var tmp_model = window_frame_ob1.clone();
            tmp_model.position.set(
              front_glass_size / 2 - (front_glass_size / 5) * i,
              0,
              0
            );
            front_glass.add(tmp_model);
          }
          front_glass_ob.add(front_glass);
          floor_2.add(front_glass_ob);

          //2층바닥
          //2층바닥
          //2층바닥
          //2층바닥
          //2층바닥
          //2층바닥
          //2층바닥
          //2층바닥

          var plane2_1_size_height =
            floor_height / 2 - ((-floor_size * 6) / 5 + stare_glace_size * 3);
          const plane2_1_geo = new THREE.PlaneGeometry(
            floor_width,
            plane2_1_size_height
          );
          const plane2_1 = new THREE.Mesh(plane2_1_geo, pmaterial);
          plane2_1.rotation.x = 1.5 * Math.PI;
          plane2_1.position.set(
            0,
            0,
            floor_height / 2 - plane2_1_size_height / 2
          );
          plane2_1.receiveShadow = true;
          plane2_1_size_height - floor_height / 2;
          var plane2_2_size_with =
            floor_size + distance_adjust * 2 + (stare_glace_size * 3) / 2; //floor_size +distance_adjust- stare_glace_size / 2
          var plane2_2_size_height =
            floor_height -
            plane2_1_size_height -
            (floor_height / 2 + pillar_posi_2);
          const plane2_2_geo = new THREE.PlaneGeometry(
            plane2_2_size_with,
            plane2_2_size_height
          );
          const texturefloor2 = new THREE.TextureLoader().load(
            "img/2f_floor_texture.jpg"
          );
          texturefloor2.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texturefloor2.wrapT = THREE.RepeatWrapping;
          texturefloor2.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texturefloor2.repeat.set(
            plane2_2_size_with / 5,
            plane2_2_size_height / 5
          );
          const pmaterial2 = new THREE.MeshPhongMaterial({
            map: texturefloor2,
            side: THREE.DoubleSide,
          });
          const plane2_2 = new THREE.Mesh(plane2_2_geo, pmaterial2);
          plane2_2.rotation.x = 1.5 * Math.PI;
          plane2_2.position.set(
            0,
            0,
            -plane2_2_size_height / 2 -
              (plane2_1_size_height - floor_height / 2)
          );
          plane2_2.receiveShadow = true;

          var plane2_3_size_with =
            floor_width / 2 -
            (floor_size + distance_adjust + 7.5 * stare_glace_size);
          var plane2_3_size_height = floor_height - plane2_1_size_height;
          const plane2_3_geo = new THREE.PlaneGeometry(
            plane2_3_size_with,
            plane2_3_size_height
          );
          const texturefloor3 = new THREE.TextureLoader().load(
            "img/2f_floor_texture.jpg"
          );
          texturefloor3.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texturefloor3.wrapT = THREE.RepeatWrapping;
          texturefloor3.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texturefloor3.repeat.set(
            plane2_3_size_with / 5,
            plane2_3_size_height / 5
          );
          const pmaterial3 = new THREE.MeshPhongMaterial({
            map: texturefloor3,
            side: THREE.DoubleSide,
          });
          const plane2_3_object = new THREE.Mesh(plane2_3_geo, pmaterial3);
          plane2_3_object.rotation.x = 1.5 * Math.PI;
          plane2_3_object.receiveShadow = true;
          var plane2_3 = new THREE.Object3D();
          plane2_3.add(plane2_3_object);

          var plane2_4_size_with =
            floor_width / 2 - (floor_size / 2 + 2 + distance_adjust);
          var plane2_4_size_height =
            floor_height / 2 -
            ((floor_size * 6) / 5 -
              stare_glace_size / 2 -
              1 +
              (plane2_1_size_height - floor_height / 2));
          const plane2_4_geo = new THREE.PlaneGeometry(
            plane2_4_size_with,
            plane2_4_size_height
          );
          const texturefloor4 = new THREE.TextureLoader().load(
            "img/2f_floor_texture.jpg"
          );
          texturefloor4.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texturefloor4.wrapT = THREE.RepeatWrapping;
          texturefloor4.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texturefloor4.repeat.set(
            plane2_2_size_with / 5,
            plane2_2_size_height / 5
          );
          const pmaterial4 = new THREE.MeshPhongMaterial({
            map: texturefloor4,
            side: THREE.DoubleSide,
          });
          const plane2_4_object = new THREE.Mesh(plane2_4_geo, pmaterial4);
          plane2_4_object.rotation.x = 1.5 * Math.PI;
          plane2_4_object.receiveShadow = true;
          var plane2_4 = new THREE.Object3D();
          plane2_4.add(plane2_4_object);

          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅
          //바닥세팅

          floor_2.add(plane2_1);
          floor_2.add(plane2_2);

          for (var i = 0; i < 2; i++) {
            var tmp_model = plane2_3.clone();
            tmp_model.position.set(
              (-1) ** i * (floor_width / 2 - plane2_3_size_with / 2),
              0,
              -plane2_3_size_height / 2 -
                (plane2_1_size_height - floor_height / 2)
            );
            floor_2.add(tmp_model);
          }
          for (var i = 0; i < 2; i++) {
            var tmp_model = plane2_4.clone();
            tmp_model.position.set(
              (-1) ** i * (floor_width / 2 - plane2_4_size_with / 2),
              0,
              -(floor_height / 2 - plane2_4_size_height / 2)
            );
            floor_2.add(tmp_model);
          }
          //

          //2층 천장
          //2층 천장
          //2층 천장
          //2층 천장
          //2층 천장
          //2층 천장
          //2층 천장

          //천장 세팅

          const ceiling_geo = new THREE.PlaneGeometry(
            floor_width,
            floor_height / 2 - pillar_posi_2
          );
          const ceiling_mat = new THREE.MeshBasicMaterial({ color: 0xc9c9c0 });
          const ceiling_object = new THREE.Mesh(ceiling_geo, ceiling_mat);
          ceiling_object.position.z =
            -(floor_height / 2 - pillar_posi_2) / 2 + floor_height / 2;
          ceiling_object.rotation.x = -1.5 * Math.PI;

          const ceiling_object_2 = new THREE.Mesh(plane2_4_geo, ceiling_mat);
          ceiling_object_2.rotation.x = -1.5 * Math.PI;
          ceiling_object_2.receiveShadow = true;
          var ceiling_object_sub = new THREE.Object3D();
          ceiling_object_sub.add(ceiling_object_2);
          var ceiling = new THREE.Object3D();
          ceiling.add(ceiling_object);

          for (var i = 0; i < 2; i++) {
            var tmp_model = ceiling_object_sub.clone();
            tmp_model.position.set(
              (-1) ** i *
                (floor_width / 2 - plane2_3_size_with - plane2_4_size_with / 2),
              0,
              -(floor_height / 2 - plane2_4_size_height / 2)
            );
            ceiling.add(tmp_model);
          }

          ceiling.position.y = height_2f - 5;
          floor_2.add(ceiling);

          //천장 전등
          var lamp_circle = new THREE.Object3D();
          var lamp_circle_size = 1;
          const lamp_circle_frame_geo = new THREE.CircleGeometry(
            (lamp_circle_size * 5) / 4,
            32
          );
          const lamp_circle_frame_mat = new THREE.MeshBasicMaterial({
            color: 0xdadada,
          }); //0xD3D3C3
          const lamp_circle_frame = new THREE.Mesh(
            lamp_circle_frame_geo,
            lamp_circle_frame_mat
          );

          const lamp_circle_geo = new THREE.CircleGeometry(
            lamp_circle_size,
            32
          );
          const lamp_circle_mat = new THREE.MeshBasicMaterial({
            color: 0xfffffff,
          });
          const lamp_circle_object = new THREE.Mesh(
            lamp_circle_geo,
            lamp_circle_mat
          );
          lamp_circle_object.position.set(0, 0, 0.1);
          const lamp_circle_light = new THREE.PointLight(0xffffff, 0.05, 100);

          lamp_circle_object.add(lamp_circle_light);
          lamp_circle_frame.add(lamp_circle_object);
          lamp_circle.add(lamp_circle_frame);
          lamp_circle_light.position.set(0, 0, 1);
          lamp_circle.rotation.x = -1.5 * Math.PI;
          lamp_circle.position.set(0, 5, 0);

          var lamp_circle2 = new THREE.Object3D();
          var lamp_circle_size = 1;
          const lamp_circle_frame_geo2 = new THREE.CircleGeometry(
            (lamp_circle_size * 5) / 4,
            32
          );
          const lamp_circle_frame_mat2 = new THREE.MeshBasicMaterial({
            color: 0xdadada,
          }); //0xD3D3C3
          const lamp_circle_frame2 = new THREE.Mesh(
            lamp_circle_frame_geo2,
            lamp_circle_frame_mat2
          );

          const lamp_circle_geo2 = new THREE.CircleGeometry(
            lamp_circle_size,
            32
          );
          const lamp_circle_mat2 = new THREE.MeshBasicMaterial({
            color: 0xfffffff,
          });
          const lamp_circle_object2 = new THREE.Mesh(
            lamp_circle_geo2,
            lamp_circle_mat2
          );
          lamp_circle_object2.position.set(0, 0, 0.1);
          const lamp_circle_light2 = new THREE.PointLight(0xffffff, 0.015, 100);

          lamp_circle_object2.add(lamp_circle_light2);
          lamp_circle_frame2.add(lamp_circle_object2);
          lamp_circle2.add(lamp_circle_frame2);
          lamp_circle_light2.position.set(0, 0, 1);
          lamp_circle2.rotation.x = -1.5 * Math.PI;
          lamp_circle2.position.set(0, 5, 0);

          //동그라미전등
          var lamp_set = new THREE.Object3D();
          for (var i = 0; i < 14; i++) {
            for (var j = 0; j < 2; j++) {
              var tmp_model = lamp_circle2.clone();
              tmp_model.position.set(
                -floor_width / 2 + 8 + i * 20,
                0,
                floor_height / 2 - floor_2f_insideWall_size - 8 - j * 8
              );
              lamp_set.add(tmp_model);
            }
          }

          //사각형 전등
          var lamp_rect = new THREE.Object3D();
          const lamp_rect_frame_geo = new THREE.PlaneGeometry(5, 30);
          const lamp_rect_frame = new THREE.Mesh(
            lamp_rect_frame_geo,
            lamp_circle_frame_mat
          );
          lamp_rect.add(lamp_rect_frame);
          for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
              var directionalLight = new THREE.DirectionalLight(0xffffff, 0.01);
              directionalLight.position.set((-1) ** j * -2.5, 1, -15 + i * 10);
              lamp_rect.add(directionalLight);
            }
          }
          lamp_rect.rotation.x = -1.5 * Math.PI;

          var sub_adjust = 0;
          for (var i = 1; i < 8; i++) {
            sub_adjust = 0;
            if (i == 4) {
              sub_adjust = 7;
            }
            var tmp_model = lamp_rect.clone();
            tmp_model.position.set(
              -floor_width / 2 + (i * floor_width) / 8,
              0,
              -floor_height / 4 + sub_adjust
            );
            lamp_set.add(tmp_model);

            for (var j = 0; j < 3; j++) {
              var tmp_model = lamp_circle.clone();
              tmp_model.position.set(
                -floor_width / 2 + (i * floor_width) / 8,
                -0.2,
                -floor_height / 4 - 10 + j * 10 + sub_adjust
              );
              lamp_set.add(tmp_model);
            }
          }

          lamp_set.position.y = height_2f - 5.1;

          //스터디룸 조명설정

          for (var i = 1; i < 5; i++) {
            var tmp_model = lamp_rect.clone();
            tmp_model.position.set(
              -floor_width / 2 -
                sturdy_room_distance1 / 2 +
                sturdy_room_distance1 * i,
              0,
              floor_height / 2 - floor_2f_insideWall_size / 2
            );
            lamp_set.add(tmp_model);

            for (var j = 0; j < 3; j++) {
              var tmp_model = lamp_circle.clone();
              tmp_model.position.set(
                -floor_width / 2 -
                  sturdy_room_distance1 / 2 +
                  sturdy_room_distance1 * i,
                0,
                floor_height / 2 - floor_2f_insideWall_size / 2
              );
              lamp_set.add(tmp_model);
            }
          }
          for (var i = 1; i < 4; i++) {
            var tmp_model = lamp_rect.clone();
            tmp_model.position.set(
              floor_width / 2 +
                sturdy_room_distance2 / 2 -
                sturdy_room_distance2 * i,
              0,
              floor_height / 2 - floor_2f_insideWall_size / 2
            );
            lamp_set.add(tmp_model);

            for (var j = 0; j < 3; j++) {
              var tmp_model = lamp_circle.clone();
              tmp_model.position.set(
                floor_width / 2 +
                  sturdy_room_distance2 / 2 -
                  sturdy_room_distance2 * i,
                0,
                floor_height / 2 - floor_2f_insideWall_size / 2
              );
              lamp_set.add(tmp_model);
            }
          }
          floor_2.add(lamp_set);

          floor_2.position.y = height_2f;
          this.add(floor_2);

          const text_loader = new FontLoader();

          text_loader.load(
            "three.js-master/examples/fonts/helvetiker_regular.typeface.json",
            (font) => {
              const W_geometry = new THREE.TextGeometry("W", {
                font: font,
                size: 300,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.15,
                bevelSize: 0.3,
                bevelSegments: 5,
              });
              const A_geometry = new THREE.TextGeometry("A", {
                font: font,
                size: 3,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.15,
                bevelSize: 0.3,
                bevelSegments: 5,
              });
              const S_geometry = new THREE.TextGeometry("S", {
                font: font,
                size: 3,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.15,
                bevelSize: 0.3,
                bevelSegments: 5,
              });
              const D_geometry = new THREE.TextGeometry("D", {
                font: font,
                size: 3,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.15,
                bevelSize: 0.3,
                bevelSegments: 5,
              });
              const text_m조정at = new THREE.MeshBasicMaterial({
                color: 0xf0f0f0,
              });
              const W_obj = new THREE.Mesh(W_geometry, text_mat);
              W_obj.position.y = 25;
              Scene.add(W_obj);
            }
          );

          const shape = new THREE.Shape();
          const x = -2.5 / 2;
          const y = -5 / 2;
          shape.moveTo(x + 2.5 / 2, y + 2.5 / 2);
          shape.bezierCurveTo(x + 2.5 / 2, y + 2.5 / 2, x + 2 / 2, y, x, y);
          shape.bezierCurveTo(
            x - 3 / 2,
            y,
            x - 3 / 2,
            y + 3.5 / 2,
            x - 3 / 2,
            y + 3.5 / 2
          );
          shape.bezierCurveTo(
            x - 3 / 2,
            y + 5.5 / 2,
            x - 1.5 / 2,
            y + 7.7 / 2,
            x + 2.5 / 2,
            y + 9.5 / 2
          );
          shape.bezierCurveTo(
            x + 6 / 2,
            y + 7.7 / 2,
            x + 8 / 2,
            y + 4.5 / 2,
            x + 8 / 2,
            y + 3.5 / 2
          );
          shape.bezierCurveTo(
            x + 8 / 2,
            y + 3.5 / 2,
            x + 8 / 2,
            y,
            x + 5 / 2,
            y
          );
          shape.bezierCurveTo(
            x + 3.5 / 2,
            y,
            x + 2.5 / 2,
            y + 2.5 / 2,
            x + 2.5 / 2,
            y + 2.5 / 2
          );
          const curveSegments = 18;
          const heart_geometry = new THREE.ShapeGeometry(shape, curveSegments);
          const heart_mat = new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
          });

          const heart_obj = new THREE.Mesh(heart_geometry, heart_mat);
          const tmp_plane_geo = new THREE.PlaneGeometry(2.5, 2.5);
          const tmp_plane_mat = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("img/move_manual.PNG"),
          });
          const tmp_plane = new THREE.Mesh(tmp_plane_geo, tmp_plane_mat);
          tmp_plane.position.y = 0.1;
          tmp_plane.position.z = -0.1;
          tmp_plane.rotation.x = Math.PI;
          heart_obj.add(tmp_plane);
          heart_obj.position.y = 40;
          heart_obj.position.z = -10;
          heart_obj.position.x = 3;
          heart_obj.rotation.x = Math.PI;
          this.add(heart_obj);

          const heart_obj1 = new THREE.Mesh(heart_geometry, heart_mat);
          const tmp_plane_mat1 = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("img/vision_manual.PNG"),
          });
          const tmp_plane1 = new THREE.Mesh(tmp_plane_geo, tmp_plane_mat1);
          tmp_plane1.rotation.x = Math.PI;
          tmp_plane1.position.y = 0.1;
          tmp_plane1.position.z = -0.1;
          heart_obj1.add(tmp_plane1);
          heart_obj1.position.y = 40;
          heart_obj1.position.z = -10;
          heart_obj1.position.x = -3;
          heart_obj1.rotation.x = Math.PI;
          this.add(heart_obj1);
          const curve = new THREE.EllipseCurve(
            0,
            0, // ax, aY
            6,
            4, // xRadius, yRadius
            0,
            2 * Math.PI, // aStartAngle, aEndAngle
            false, // aClockwise
            0 // aRotation
          );

          const curve_points = curve.getPoints(50);
          const curve_geometry = new THREE.BufferGeometry().setFromPoints(
            curve_points
          );

          const curve_material = new THREE.LineBasicMaterial({
            color: 0xff0000,
          });

          // Create the final object to add to the scene
          const ellipse = new THREE.Line(curve_geometry, curve_material);
          ellipse.position.y = 40;
          ellipse.position.z = -10;
          this.add(ellipse);
          //3층
          //3층
          //3층
          //3층
          //3층
          //3층
          //3층
          //3층
          //3층
          //3층
          //3층

          //3층 좌우측 외벽
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 9; i++) {
              var tmp_model = wall_out.clone();
              tmp_model.position.set(
                (-1) ** j * (-floor_width / 2 - wall_out_half),
                0,
                floor_height / 2 - i * window_glace_size
              );
              floor_3.add(tmp_model);
              if (i == 8) {
                continue;
              }
              var tmp_model2 = wall_window.clone();
              tmp_model2.position.set(
                (-1) ** j * (-floor_width / 2 - wall_out_half),
                0,
                floor_height / 2 -
                  ((wall_out_size * 3) / 2 + i * window_glace_size)
              );
              if (j) {
                tmp_model2.rotation.y = Math.PI * -0.5;
              } else {
                tmp_model2.rotation.y = Math.PI * 0.5;
              }
              floor_3.add(tmp_model2);
            }
          }
          //3층 정면 외벽
          for (var k = 0; k < 2; k++) {
            for (var j = 0; j < 2; j++) {
              for (var i = 0; i < 11; i++) {
                var tmp_model = wall_out.clone();
                tmp_model.position.set(
                  (-1) ** j *
                    (+floor_width / 2 + wall_out_half - i * window_glace_size),
                  0,
                  (-1) ** k * (-floor_height / 2 - wall_out_half)
                );
                floor_3.add(tmp_model);
                if (i == 10) {
                  continue;
                }
                var tmp_model2 = wall_window.clone();
                tmp_model2.position.set(
                  (-1) ** j *
                    (+floor_width / 2 +
                      wall_out_half -
                      ((wall_out_size * 3) / 2 + i * window_glace_size)),
                  0,
                  (-1) ** k * (-floor_height / 2 - wall_out_half)
                );
                floor_3.add(tmp_model2);
              }
            }
          }

          const floor_bottom_3_geo = new THREE.PlaneGeometry(
            floor_width,
            floor_height / 2 - pillar_posi_2
          );
          const floor_bottom_3_mat = new THREE.MeshBasicMaterial({
            color: 0xc9c9c0,
          });
          const floor_bottom_3_object = new THREE.Mesh(
            floor_bottom_3_geo,
            pmaterial
          );
          floor_bottom_3_object.position.z =
            -(floor_height / 2 - pillar_posi_2) / 2 + floor_height / 2;
          floor_bottom_3_object.rotation.x = 1.5 * Math.PI;

          const floor_bottom_3_object_2 = new THREE.Mesh(
            plane2_4_geo,
            pmaterial3
          );
          floor_bottom_3_object_2.rotation.x = 1.5 * Math.PI;
          floor_bottom_3_object_2.receiveShadow = true;
          var floor_bottom_3_object_sub = new THREE.Object3D();
          floor_bottom_3_object_sub.add(floor_bottom_3_object_2);
          var floor_bottom_3 = new THREE.Object3D();
          floor_bottom_3.add(floor_bottom_3_object);

          for (var i = 0; i < 2; i++) {
            var tmp_model = floor_bottom_3_object_sub.clone();
            tmp_model.position.set(
              (-1) ** i * (floor_width / 2 - plane2_4_size_with / 2),
              0,
              -(floor_height / 2 - plane2_4_size_height / 2)
            );
            floor_bottom_3.add(tmp_model);
          }

          floor_3.add(floor_bottom_3);

          //floor_bottom_3.position.y=height_2f-5;

          var front_glass_ob_3 = front_glass_ob.clone();
          floor_3.add(front_glass_ob_3);
          var tmp_wall1 = miniwall_obj.clone();
          floor_3.add(tmp_wall1);
          var tmp_wall2 = miniwall_obj2.clone();
          floor_3.add(tmp_wall2);

          this.add(floor_3); //이게진짜

          //4층
          //4층
          //4층
          //4층
          //4층
          //4층
          //4층
          //4층
          //4층

          var floor_4 = new THREE.Object3D();

          //4층 좌우벽
          for (var j = 0; j < 2; j++) {
            for (var i = 0; i < 9; i++) {
              var tmp_model = wall_out.clone();
              tmp_model.position.set(
                (-1) ** j * (-floor_width / 2 - wall_out_half),
                0,
                floor_height / 2 - i * window_glace_size
              );
              floor_4.add(tmp_model);
              if (i == 8) {
                continue;
              }
              var tmp_model2 = wall_window.clone();
              tmp_model2.position.set(
                (-1) ** j * (-floor_width / 2 - wall_out_half),
                0,
                floor_height / 2 -
                  ((wall_out_size * 3) / 2 + i * window_glace_size)
              );
              if (j) {
                tmp_model2.rotation.y = Math.PI * -0.5;
              } else {
                tmp_model2.rotation.y = Math.PI * 0.5;
              }
              floor_4.add(tmp_model2);
            }
          }

          //4층 정면 후면 벽

          for (var k = 0; k < 2; k++) {
            for (var j = 0; j < 2; j++) {
              for (var i = 0; i < 13; i++) {
                var tmp_model = wall_out.clone();
                tmp_model.position.set(
                  (-1) ** j *
                    (+floor_width / 2 + wall_out_half - i * window_glace_size),
                  0,
                  (-1) ** k * (-floor_height / 2 - wall_out_half)
                );
                floor_4.add(tmp_model);
                if (i == 12) {
                  continue;
                }
                var tmp_model2 = wall_window.clone();
                tmp_model2.position.set(
                  (-1) ** j *
                    (+floor_width / 2 +
                      wall_out_half -
                      ((wall_out_size * 3) / 2 + i * window_glace_size)),
                  0,
                  (-1) ** k * (-floor_height / 2 - wall_out_half)
                );
                floor_4.add(tmp_model2);
              }
            }
          }

          var tmp_ceiling_4floor = new THREE.Object3D();
          tmp_ceiling_4floor.add(plane3);
          floor_4.add(tmp_ceiling_4floor);
          var tmp_ceiling_4floor2 = tmp_ceiling_4floor.clone();
          tmp_ceiling_4floor2.position.y = height_2f;
          floor_4.add(tmp_ceiling_4floor2);

          floor_4.position.set(0, 75, 0);
          this.add(floor_4);

          //1층
          //1층
          //1층
          //1층
          //1층
          //1층
          //1층
          //1층
          //1층
          //1층
          //1층

          var floor_1 = new THREE.Object3D();

          var floor_1_width = floor_width - floor_size;
          var floor_1_height = -pillar_posi_2 * 2;
          const floor_1_bottom_geo = new THREE.PlaneGeometry(
            floor_1_width,
            floor_1_height
          );
          const texturefloor_1 = new THREE.TextureLoader().load(
            "img/2f_wall_inside.jpg"
          );
          texturefloor_1.wrapS = THREE.RepeatWrapping; // 랩핑 모드 -> texture를 무한으로 반복
          texturefloor_1.wrapT = THREE.RepeatWrapping;
          texturefloor_1.magFilter = THREE.NearestFilter; // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
          texturefloor_1.repeat.set(floor_width / 10, floor_height / 10);
          const floor_1_bottom_mat = new THREE.MeshPhongMaterial({
            map: texturefloor_1,
          });
          const floor_1_bottom = new THREE.Mesh(
            floor_1_bottom_geo,
            floor_1_bottom_mat
          );
          floor_1_bottom.rotation.x = 1.5 * Math.PI;
          floor_1_bottom.receiveShadow = true;
          floor_1.add(floor_1_bottom);

          //1층 후면 벽
          //1층 후면 벽
          //1층 후면 벽
          //1층 후면 벽
          //1층 후면 벽
          //1층 후면 벽
          //1층 후면 벽

          var floor_1_back_glass = new THREE.Object3D();
          const front_glass_geo1 = new THREE.PlaneGeometry(
            floor_1_width,
            height_2f
          );
          const front_glass1 = new THREE.Mesh(
            front_glass_geo1,
            window_glace_mat
          );
          front_glass1.position.set(0, height_2f / 2, -pillar_posi_2);

          const window_frame_geo21 = new THREE.BoxGeometry(
            floor_1_width,
            0.3,
            0.3
          );
          const window_frame_geo31 = new THREE.BoxGeometry(0.3, height_2f, 0.3);
          const window_frame31 = new THREE.Mesh(
            window_frame_geo21,
            window_frame_mat
          );
          const window_frame41 = new THREE.Mesh(
            window_frame_geo31,
            window_frame_mat
          );
          var window_frame_ob_floor1 = new THREE.Object3D();
          var window_frame_ob_floor1_2 = new THREE.Object3D();
          window_frame_ob_floor1.add(window_frame31);
          window_frame_ob_floor1_2.add(window_frame41);
          for (var i = 0; i < 3; i++) {
            var tmp_model = window_frame_ob_floor1.clone();
            tmp_model.position.set(0, height_2f / 2 - (height_2f / 2) * i, 0);
            front_glass1.add(tmp_model);
          }
          for (var i = 0; i < 16; i++) {
            var tmp_model = window_frame_ob_floor1_2.clone();
            tmp_model.position.set(
              floor_1_width / 2 - (floor_1_width / 15) * i,
              0,
              0
            );
            front_glass1.add(tmp_model);
          }
          floor_1_back_glass.add(front_glass1);
          floor_1.add(floor_1_back_glass);

          //1층 좌우 벽
          //1층 좌우 벽
          //1층 좌우 벽
          //1층 좌우 벽
          //1층 좌우 벽
          //1층 좌우 벽
          //1층 좌우 벽
          //1층 좌우 벽

          var floor_1_side_glass = new THREE.Object3D();

          const front_glass_geo2 = new THREE.PlaneGeometry(
            floor_1_height,
            height_2f
          );
          const front_glass2 = new THREE.Mesh(
            front_glass_geo2,
            window_glace_mat
          );
          front_glass2.position.set(floor_1_width / 2, height_2f / 2, 0);
          front_glass2.rotation.y = 0.5 * Math.PI;

          const window_frame_geo22 = new THREE.BoxGeometry(
            floor_1_height,
            0.3,
            0.3
          );
          const window_frame_geo32 = new THREE.BoxGeometry(0.3, height_2f, 0.3);
          const window_frame32 = new THREE.Mesh(
            window_frame_geo22,
            window_frame_mat
          );
          const window_frame42 = new THREE.Mesh(
            window_frame_geo32,
            window_frame_mat
          );
          var window_frame_ob_floor1_2 = new THREE.Object3D();
          var window_frame_ob_floor1_2_2 = new THREE.Object3D();
          window_frame_ob_floor1_2.add(window_frame32);
          window_frame_ob_floor1_2_2.add(window_frame42);
          for (var i = 0; i < 3; i++) {
            var tmp_model = window_frame_ob_floor1_2.clone();
            tmp_model.position.set(0, height_2f / 2 - (height_2f / 2) * i, 0);
            front_glass2.add(tmp_model);
          }
          for (var i = 0; i < 6; i++) {
            var tmp_model = window_frame_ob_floor1_2_2.clone();
            tmp_model.position.set(
              floor_1_height / 2 - (floor_1_height / 5) * i,
              0,
              0
            );
            front_glass2.add(tmp_model);
          }
          floor_1_side_glass.add(front_glass2);
          floor_1.add(floor_1_side_glass);

          var tmp_copy = floor_1_side_glass.clone();
          tmp_copy.position.x = -floor_1_width;
          floor_1.add(tmp_copy);

          //1층 정면벽
          //1층 정면벽
          //1층 정면벽
          //1층 정면벽
          //1층 정면벽
          //1층 정면벽

          var floor_1_front_glass = new THREE.Object3D();
          var floor_1_front_glass_size = 107;

          const front_glass_geo3 = new THREE.PlaneGeometry(
            floor_1_front_glass_size,
            height_2f
          );
          const front_glass3 = new THREE.Mesh(
            front_glass_geo3,
            window_glace_mat
          );
          front_glass3.position.set(
            25 + floor_1_front_glass_size / 2,
            height_2f / 2,
            pillar_posi_2
          );

          const window_frame_geo23 = new THREE.BoxGeometry(
            floor_1_front_glass_size,
            0.3,
            0.3
          );
          const window_frame_geo33 = new THREE.BoxGeometry(0.3, height_2f, 0.3);
          const window_frame33 = new THREE.Mesh(
            window_frame_geo23,
            window_frame_mat
          );
          const window_frame43 = new THREE.Mesh(
            window_frame_geo33,
            window_frame_mat
          );
          var window_frame_ob_floor1_3 = new THREE.Object3D();
          var window_frame_ob_floor1_2_3 = new THREE.Object3D();
          window_frame_ob_floor1_3.add(window_frame33);
          window_frame_ob_floor1_2_3.add(window_frame43);
          for (var i = 0; i < 3; i++) {
            var tmp_model = window_frame_ob_floor1_3.clone();
            tmp_model.position.set(0, height_2f / 2 - (height_2f / 2) * i, 0);
            front_glass3.add(tmp_model);
          }
          for (var i = 0; i < 11; i++) {
            var tmp_model = window_frame_ob_floor1_2_3.clone();
            tmp_model.position.set(
              floor_1_front_glass_size / 2 -
                (floor_1_front_glass_size / 10) * i,
              0,
              0
            );
            front_glass3.add(tmp_model);
          }
          floor_1_front_glass.add(front_glass3);
          floor_1.add(floor_1_front_glass);

          var tmp_copy = floor_1_front_glass.clone();
          tmp_copy.position.x = -floor_1_front_glass_size - 50;
          floor_1.add(tmp_copy);

          //set light
          var ambient = new THREE.AmbientLight(0xffffff, 0.4);
          this.add(ambient);

          this.add(floor_1);
          //-------------------------------------------------

          //옥상
          //옥상
          //옥상
          //옥상
          //옥상
          //옥상
          //옥상
          //옥상

          var rooftop = new THREE.Object3D();
          const rectangle1_geo = new THREE.BoxGeometry(
            floor_1_width,
            6,
            floor_1_height
          );
          const rectangle1_mat = new THREE.MeshPhysicalMaterial({
            roughness: 0.3,
            metalness: 0.275,
            color: 0x36393a,
          });
          const rectangle1 = new THREE.Mesh(rectangle1_geo, rectangle1_mat);
          rectangle1.position.set(0, 3, 0);

          const rectangle1_geo2 = new THREE.BoxGeometry(
            floor_width + pillar_size * 2,
            5,
            floor_height + 2 * pillar_size
          );

          const rectangle2 = new THREE.Mesh(rectangle1_geo2, rectangle1_mat);
          rectangle2.position.set(0, 8.5, 0);
          rooftop.add(rectangle1);
          rooftop.add(rectangle2);

          rooftop.position.y = 100;
          this.add(rooftop);
        }

        #addLights() {
          const directional = new THREE.DirectionalLight(0xffffff, 2);
          directional.position.set(50, 50, 50);
          directional.target.position.set(0, 0, 0);
          directional.castShadow = true;
          this.add(directional);

          const ambient = new THREE.AmbientLight(0xffffff, 0.5);
          this.add(ambient);
        }

        #update = (elapsedTime) => {
          this.#renderer.setSize(window.innerWidth, window.innerHeight);

          // Rotate the camera
          const easeIn = 91;
          let { x: yRotation, y: xRotation } = this.#controls.rotation;
          xRotation = Math.pow(xRotation, easeIn);
          const cameraRotation = new THREE.Euler(xRotation, yRotation, 0);
          this.#orbital.update(elapsedTime, cameraRotation);

          // Reposition the player
          const { x: xPos, y: zPos } = this.#controls.position;
          const playerPosition = new THREE.Vector3(xPos, 0, zPos);
          playerPosition.multiplyScalar(Scene.timeDilation);
          // This applies any orbital rotation to the new player position so that the "forward" direction (the A key) will always move the player "up" on the screen (and the same for left, down, and right).
          playerPosition.applyEuler(this.#orbital.rotation);
          this.#player.update(elapsedTime, playerPosition);
        };

        #render = (timestamp) => {
          if (this.#prevTimestamp === undefined)
            this.#prevTimestamp = timestamp;

          const elapsedTime = (timestamp - this.#prevTimestamp) / 1000;
          this.#renderer.render(this, this.#orbital.camera);
          this.#update(elapsedTime);
          this.#prevTimestamp = timestamp;

          this.#renderer.render(this, this.#orbital.camera);
        };
      }

      class OrbitalCamera extends THREE.Object3D {
        #originalCameraAngle;
        #originalCameraHeight;

        constructor(fov, aspect, near, far) {
          super();

          this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
          this.camera.position.set(2, 45, 30);
          this.camera.lookAt(0, 35, 0);
          this.add(this.camera);
          this.#originalCameraAngle = this.camera.rotation.x;
          this.#originalCameraHeight = this.camera.position.y;
        }

        update(elapsedTime, rotation) {
          if (rotation instanceof THREE.Euler) {
            const pitch = rotation.x * -0.5;
            const yaw = this.rotation.y + rotation.y * -elapsedTime;

            this.rotation.set(this.rotation.x, yaw, this.rotation.z);

            const camAltitude = this.camera.position.clone();
            camAltitude.setY(this.#originalCameraHeight + rotation.x * 10);
            this.camera.position.lerp(camAltitude, 0.1);

            const camPitch = this.camera.quaternion.clone();
            camPitch.setFromAxisAngle(
              new THREE.Vector3(1, 0, 0),
              this.#originalCameraAngle - rotation.x * 0.5
            );
            this.camera.quaternion.slerp(camPitch, 0.1);
          }

          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
        }
      }

      class Player extends THREE.Group {
        #action;
        #actionList = {};
        #areModelsLoaded = false;
        #mixer;
        #model;

        constructor(props) {
          super();

          const { animationNames, modelName, onLoad, path } = props;
          const loader = new FBXLoader();
          loader.setPath(path);
          loader.load(
            `${modelName}.fbx`,
            (model) => {
              model.scale.setScalar(0.1);

              model.traverse((mesh) => {
                mesh.castShadow = true;
                if (mesh.material?.name === "asdf1:Beta_HighLimbsGeoSG2") {
                  mesh.material.color.setHex(0x333333);
                  mesh.metalicness = 1;
                  mesh.roughness = 0;
                } else if (mesh.material?.name === "Beta_Joints_MAT") {
                  mesh.material.color.setRGB(
                    (Math.floor(Math.random() * 80) + 20) / 100,
                    (Math.floor(Math.random() * 80) + 20) / 100,
                    (Math.floor(Math.random() * 80) + 20) / 100
                  );
                }
              });

              model.position.set(0, 25, 0);
              model.setRotationFromAxisAngle(
                new THREE.Vector3(0, 1, 0),
                Math.PI
              );
              this.#model = model;
              this.add(model);

              this.#mixer = new THREE.AnimationMixer(this.#model);

              const loadingManager = new THREE.LoadingManager();
              const loader = new FBXLoader(loadingManager);
              loader.setPath(path);
              loadingManager.onLoad = () => {
                this.#areModelsLoaded = true;
                this.#setAction("idle");
                if (typeof onLoad === "function") onLoad();
              };

              animationNames.forEach((name) => {
                loader.load(`${name}.fbx`, (model) => {
                  const clip = model.animations[0];
                  const action = this.#mixer.clipAction(clip);
                  action.name = name;

                  this.#actionList[name] = action;
                });
              });
            },
            null,
            (e) => console.log(e)
          );
        }

        update = (elapsedTime, movement) => {
          if (!this.#action) return;
          this.#animate(elapsedTime, movement);
          this.#move(elapsedTime, movement);
        };

        #animate = (elapsedTime, movement) => {
          const { x, z } = movement;

          const speed = Math.min(Math.abs(x) + Math.abs(z), 1);

          let action = "idle";

          if (speed === 0) action = "idle";
          else if (speed < 0.3) action = "walk";
          else action = "run";

          this.#setAction(action);
          this.#mixer.update(elapsedTime);
        };

        #move = (elapsedTime, movement) => {
          if (!movement instanceof THREE.Vector3) return;
          if (movement.x === 0 && movement.z === 0) return;

          const nextPosition = this.position.clone();
          nextPosition.add(movement);

          const angle =
            Math.PI +
            Math.atan2(
              this.position.x - nextPosition.x,
              this.position.z - nextPosition.z
            );

          this.position.copy(nextPosition);

          if (this.#model)
            this.#model.setRotationFromAxisAngle(
              new THREE.Vector3(0, 1, 0),
              angle
            );
        };

        #setAction(name) {
          const prevAction = this.#action;
          if (prevAction?.name === name) return;

          this.#action = this.#actionList[name];

          if (prevAction) {
            this.#action.time = 0.1;
            this.#action.enabled = true;
            this.#action.setEffectiveTimeScale(Scene.timeDilation);
            this.#action.setEffectiveWeight(1.0);
            this.#action.crossFadeFrom(prevAction, 0.5, true);
          }

          this.#action.play();
        }
      }

      class KeyboardInput extends THREE.Vector3 {
        #activeKeys = new Set();
        #keyMapping = {};

        constructor(keyMapping) {
          super();

          if (keyMapping) this.#keyMapping = keyMapping;
          window.addEventListener("keydown", this.onKeyDown);
          window.addEventListener("keyup", this.onKeyUp);
        }

        onKeyDown = (e) => {
          const key = e.key.toLowerCase();
          const activeKeys = this.#activeKeys;
          const { left, right, up, down } = this.#keyMapping;

          activeKeys.add(key);
          switch (key) {
            case left:
              this.setX(-1);
              break;
            case right:
              this.setX(1);
              break;
            case up:
              this.setY(1);
              break;
            case down:
              this.setY(-1);
              break;
            default:
              break;
          }
        };

        onKeyUp = (e) => {
          const key = e.key.toLowerCase();
          const activeKeys = this.#activeKeys;
          const { left, right, up, down } = this.#keyMapping;

          activeKeys.delete(key);

          switch (key) {
            case left:
              if (!activeKeys.has(right)) this.setX(0);
              break;
            case right:
              if (!activeKeys.has(left)) this.setX(0);
              break;
            case up:
              if (!activeKeys.has(down)) this.setY(0);
              break;
            case down:
              if (!activeKeys.has(up)) this.setY(0);
              break;
            default:
              break;
          }
        };

        //여기서부터 코드 배치
        //여기서부터 코드 배치
        //여기서부터 코드 배치
        //여기서부터 코드 배치
        //여기서부터 코드 배치
        //여기서부터 코드 배치
        //여기서부터 코드 배치
        //여기서부터 코드 배치
      }

      new Scene();
    </script>
  </body>
</html>
